# Chapter 03 - 코드에서 나는 악취

리팩토링을 언제 시작하고, 언제 그만할지를 판단하는 일은 리팩토링의 작동 원리를 아는 것 만큼 중요하다.

어떤 상황에서 어떤 리팩토링 기법을 적용할지 정리하자. (리팩토링이 필요한 부분 = 악취)

</br>

## 기이한 이름

함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각가 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 신경써서 이름을 지어야 한다.

이름만 잘 지어도 나중에 문맥을 파악하는데 헤매는 시간을 크게 절약할 수 있다.

> 함수 선언 바꾸기(6.5), 변수 이름 바꾸기(6.7), 필드 이름 바꾸기(9.2)

</br>

## 중복 코드

똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.
> 함수 추출하기(6.1), 문장 슬라이드하기(8.6), 메서드 올리기(12.1)

</br>

## 긴 함수

코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나온다. 함수가 길수록 사람들은 함수를 이해하기 힘들다.
> 함수 추출하기(6.1), 임시변수를 질의 함수로 바꾸기(7.4), 매개변수 객체 만들기(6.8), 객체 통째로 넘기기(11.4), 함수를 명령으로 바꾸기(11.9), 조건문 분해하기(10.1), 조건부 로직을 다형성으로 바꾸기(10.4), 반복문 쪼개기(8.7)

</br>

## 긴 매개변수 목록

매개변수 목록이 길어질수록 코드를 이해하기 어렵다.
> 매개변수를 질의 함수로 바꾸기(11.5), 객체 통쨰로 넘기기(11.4), 매개변수 객체 만들기(6.8), 플래그 인수 제거하기(11.3), 여러 함수를 클래스로 묶기(6.9)

</br>

## 전역 데이터

전역 데이터는 코드 베이스 어디서든 건드릴 수 있고, 값을 누가 바꿨는지 찾아낼 매커니즘이 없다는게 문제다. 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 변수 리팩토링 하자
> 변수 캡슐화하기(6.6)

</br>

## 가변 데이터

데이터를 변경했더니 예상치 못한 결과나 버그로 이어지는 경우가 종종 있다.
> 변수 캡슐화하기(6.6), 변수 쪼개기(9.1), 문장 슬라이드하기(8.6), 함수 추출하기(6.1), 질의 함수와 변경 함수 분리하기(11.1), 세터 제거하기(11.7), 파생 변수를 질의 함수로 바꾸기(9.3), 여러 함수를 클래스로 묶기(6.9), 여러 함수를 변환 함수로 묶기(6.10), 참조를 값으로 바꾸기(9.4)

</br>

## 뒤엉킨 변경

하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다. 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있기를 바란다. 뒤엉킨 변경은 단일 책임 원칙이 지켜지지 않았을 때 나타난다.
> 단계 쪼개기(6.11), 함수 옮기기(8.1), 함수 추출하기(6.1), 클래스 추출하기(7.5)

</br>

## 산탄총 수술

산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정반대다. 변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.
> 함수 옮기기(8.1), 필드 옮기기(8.2), 여러 함수를 클래스로 묶기(6.9), 여러 함수를 변환 함수로 묶기(6.10), 함수 인라인하기(6.2), 클래스 인라인하기(7.6)

</br>

## 기능 편애

프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력한다. 기능 편애는 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호 작용할 일이 더 많을 때 나타난다. 적절히 모듈 이동을 시키면 된다.
> 함수 옮기기(8.1), 함수 추출하기(6.1)

</br>

## 데이터 뭉치

몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야 한다.
> 클래스 추출하기(7.5), 매개변수 객체 만들기(6.8), 객체 통째로 넘기기(11.4)

</br>

## 기본형 집착

최소한 사용자에게 보여줄 때는 일관된 형식으로 출력해주는 기능이라도 갖추어야 한다.
> 기본형을 객체로 바꾸기(7.3), 타입 코드를 서브클래스로 바꾸기(12.6), 조건부 로직을 다형성으로 바꾸기(10.4), 클래스 추출하기(7.5), 매개변수 객체 만들기(6.8)

</br>

## 반복되는 switch문

switch 문은 최대한 리팩토링 해야 한다. 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문도 모두 찾아서 함께 수정해야 하기 때문이다.
> 조건부 로직을 다형성으로 바꾸기(10.4)

</br>

## 반복문

반복문을 파이프라인으로 바꿔보자
> 반복문을 파이프라인으로 바꾸기(8.8)

</br>

## 성의 없는 요소

본문 코드를 그대로 쓰는 것과 다름 없는 함수나 실질적으로 메서드가 하나뿐인 클래스들은 리팩토링하자.
> 함수 인라인하기(6.2), 클래스 인라인하기(7.6), 계층 합치기(12.9)

</br>

## 추측성 일반화

미래를 대비해 작성한 부분을 실제로 사용하게 되면 다행이지만, 그렇지 않는다면 쓸데없는 낭비일 뿐이다. 걸리적거리는 코드는 치우자.
> 계층 합치기(12.9), 함수 인라인하기(6.2), 클래스 인라인하기(7.6), 함수 선언 바꾸기(6.5), 죽은 코드 제거하기(8.9)

</br>

## 임시 필드

임시 필드를 갖도록 작성하면 코드를 이해하기 어렵다.
> 클래스 추출하기(7.5), 함수 옮기기(8.1), 특이 케이스 추가하기(10.5)

</br>

## 메시지 체인

메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다. 이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다. 그래서 내비게이션 중단 단계를 수정하면 클라이언트 코드도 수정되어야 한다.
> 위임 숨기기(7.7), 함수 추출하기(6.1), 함수 옮기기(8.1)

</br>

## 중개자

객체의 대표적인 기능 하나로, 캡슐화가 있다. 캡슐화하는 과정에서 위임이 자주 활용이 되는데 지나치면 문제가 된다.
> 중개자 제거하기(7.8), 함수 인라인하기(6.2)

</br>

## 내부자 거래

모듈 사이의 데이터 거래가 많으면 결합도가 높아진다. 일이 돌아가게 하려면 거래가 이뤄질 수 밖에 없지만, 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.
> 함수 옮기기(8.1), 필드 옮기기(8.2), 위임 숨기기(7.7), 서브클래스를 위임으로 바꾸기(12.10), 슈퍼클래스를 위임으로 바꾸기(12.11)

</br>

## 거대한 클래스

한 클래스에서 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다. 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다. 클래스 안에서 자체적으로 중복을 제거하자.
> 클래스 추출하기(7.5), 슈퍼클래스 추출하기(12.8), 타입 코드를 서브클래스로 바꾸기(12.6)

</br>

## 서로 다른 인터페이스의 대안 클래스들

클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이다. 단, 교체하려면 인터페이스가 같아야 한다.
> 함수 선언 바꾸기(6.5), 함수 옮기기(8.1), 슈퍼클래스 추출하기(12.8)

</br>

## 데이터 클래스

데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다.
> 레코드 캡슐화하기(7.1), 세터 제거하기(11.7), 함수 옮기기(8.1), 함수 추출하기(6.1), 단계 쪼개기(6.11)

</br>

## 상속 포기

서브 클래스는 부모로부터 메서드와 데이터를 물려받는다. 부모로 받은 것들이 필요 없을 수 있다.
> 서브클래스를 위임으로 바꾸기(12.10), 슈퍼클래스를 위임으로 바꾸기(12.11)

</br>

## 주석

주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩토링해보자.
> 함수 추출하기(6.1), 함수 선언 바꾸기(6.5), 어서션 추가하기(10.6)
